## 目录
---
- [二叉树](#二叉树)
  - [二叉树的性质](#二叉树的性质)
  - [二叉树的算法](#二叉树的算法)
    - [二叉树的深度](#二叉树的深度)
    - [二叉树中的节点个数](#二叉树中的节点个数)
    - [遍历](#遍历)
    - [判断二叉树是不是平衡二叉树](#判断二叉树是不是平衡二叉树)
    - [判断二叉树是不是完全二叉树](#判断二叉树是不是完全二叉树)
---





# 二叉树



## 二叉树的性质



1. 在二叉树的第i层上最多有2^i-1 个节点 。（i>=1）

2. 二叉树中如果深度为k,那么最多有2k-1个节点

3. n0=n2+1  n0表示度数为0的节点 n2表示度数为2的节点

    1. n=n0+n1+n2    n表示二叉树中的节点总个数,n1表示度数为1的节点个数

    2. n-1=2n2+n1     通过观察二叉树我们可知，除了根节点之外，其余的任何节点都有一个入口分支，其他节点都有一个入口分支，那么节点的总分支数等于节点个数减一，度数为2的节点有2个出口分支，度数为一的有1个出口分支，度数为0的节点没有出口分支 所以总的分支个数为 2n2+n1



4. 在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]+1是向下取整。



满二叉树必为完全二叉树，反之不然。完全二叉树只需要i-1层完整，i层按从左至右的顺序排列就行



5. 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：

(1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点;  

(2) 若 2i>n，则该结点无左孩子，  否则，编号为 2i 的结点为其左孩子结点；

(3) 若 2i+1>n，则该结点无右孩子结点，  否则，编号为2i+1 的结点为其右孩子结点。



## 二叉树的算法

### 二叉树的宽度

二叉树的宽度定义为各层节点数的最大值。



### 二叉树的深度

二叉树的深度定义为：从根节点到叶子结点依次经过的结点形成树的一条路径,最长路径的长度为树的深度。



1. 如果根节点为空，则深度为0；



2. 如果左右节点都是空，则深度为1；



3. 递归思想：二叉树的深度=max（左子树的深度，右子树的深度）+ 1



### 二叉树中的节点个数

1. 如果二叉树为空，节点个数为0

2. 如果二叉树不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + 1



### 遍历



- 先序遍历

先访问根，再遍历左子树，再遍历右子树。典型的递归思想



- 中序遍历

先遍历左子树，再访问根，再遍历右子树。

** 对于二叉排序树来说，中序遍历得到的序列是一个从小到大排序好的序列。**



- 后序遍历

先遍历左子树，再遍历右子树，再访问根。



- 层次遍历（按层次从上往下，从左往右）

相当于广度优先搜索，使用队列实现。队列初始化，将根节点压入队列。当队列不为空，进行如下操作：弹出一个节点，访问，若左子节点或右子节点不为空，将其压入队列。



### 判断二叉树是不是平衡二叉树

递归解法：

1. 如果二叉树为空，返回真

2. 如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返



### 判断二叉树是不是完全二叉树

若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。



有如下算法，按层次（从上到下，从左到右）遍历二叉树，当遇到一个节点的左子树为空时，则该节点右子树必须为空，且后面遍历的节点左

右子树都必须为空，否则不是完全二叉树

