## 目录
---
- [TCP连接的三次握手，四次挥手](#TCP连接的三次握手，四次挥手)
  - [三次握手](#三次握手)
  - [四次挥手](#四次挥手)
  - [为什么关闭需要四次](#为什么关闭需要四次)
  - [TCP窗口](#TCP窗口)
  - [TCP拥塞控制](#TCP拥塞控制)
    - [慢启动，拥塞控制](#慢启动，拥塞控制)
    - [快重传，快恢复](#快重传，快恢复)
---





## TCP连接的三次握手，四次挥手



### 三次握手



![](http://blog.chinaunix.net/attachment/201304/8/22312037_1365405910EROI.png)





1. 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

2. 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

3. 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。





### 四次挥手



![](http://blog.chinaunix.net/attachment/201304/9/22312037_1365503104wDR0.png)





由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。



1. 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

2. 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

3. 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

4. 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。





### 为什么关闭需要四次



TCP建立连接要进行3次握手,而断开连接要进行4次,这是由于TCP的半关闭造成的,因为TCP连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭,这个单方向的关闭就叫半关闭.



关闭的方法是一方完成它的数据传输后,就发送一个FIN来向另一方通告将要终止这个方向的连接.当一端收到一个FIN,它必须通知应用层TCP连接已终止了这个方向的数据传送,发送FIN通常是应用层进行关闭的结果.



我的理解：

由于TCP是全双工的，当一方发起关闭请求的时候，说明一方没有可以传送的数据了，己方确认OK，告诉对方可以关闭你那边的连接（只是不发送，还可以接收）。但是我这边还可能有数据发送，所以等我这边需要关闭连接的时候，我会再发送FIN报文，告诉对方，我这里也没什么想说的了。所以FIN和ACK一般是分开发送的





### TCP窗口



TCP默认以1段为单位发送数据，每一段需要接收一个确认，这样的效率比较低下，所以引入了滑动窗口的概念。窗口大小是无需等待就可发送的最大单位。当接受的应答后，窗口会滑动到对应的应答序号。所以，就算中途有几个ACK的回复丢失了。但是接收到了序号更大的ACK报文。那么依然可以确认之前的数据都接受了。所以窗口可以直接滑动。



如果某一段数据真的丢失了，那么发送端会一直收到该序号的应答，表示“我需要收到该序号报文， 你老给我发其他的干嘛？”，当连续3次收到这样的报文后，发送端会将对应的数据重发。



![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f5e2be9ad388d43fe4a499a01c77b97e/42166d224f4a20a44fc2252895529822730ed004.jpg)



### TCP拥塞控制

有了窗口的概念后，收发主机发送的数据就不再是以一个段为单位了。可能会发送大量数据包，但是如果通信刚开始就发送大量数据包，可能会阻塞其他通信。当网络出现阻塞的时候，如果突然发送大量数据，可能会导致网络瘫痪。



所以为了解决这个问题，引入了一个慢启动的概念，对发送数据进行控制。

1. 慢开始、拥塞控制

2. 快重传、快恢复



#### 慢启动，拥塞控制

1. 发送方维持一个叫做“拥塞窗口”的变量，该变量和接收端口共同决定了发送者的发送窗口；

2. 当主机开始发送数据时，避免一下子将大量字节注入到网络，造成或者增加拥塞，选择发送一个1字节的试探报文；

3. 当收到第一个字节的数据的确认后，就发送2个字节的报文；

4. 若再次收到2个字节的确认，则发送4个字节，依次递增2的指数级；

5. 最后会达到一个提前预设的“慢开始门限”，比如24，即一次发送了24个分组，此时遵循下面的条件判定：

    1. cwnd < ssthresh， 继续使用慢开始算法；

    2. cwnd > ssthresh，停止使用慢开始算法，改用拥塞避免算法；

    3. cwnd = ssthresh，既可以使用慢开始算法，也可以使用拥塞避免算法；

6. 所谓拥塞避免算法就是：每经过一个往返时间RTT就把发送方的拥塞窗口+1，即让拥塞窗口缓慢地增大，按照线性规律增长；

7. 当出现网络拥塞，比如丢包时，将慢开始门限设为原先的一半，然后将cwnd设为1，执行慢开始算法（较低的起点，指数级增长）；



![](http://blog.chinaunix.net/attachment/201402/17/26275986_1392629245IG6b.png?_=3554182)





#### 快重传，快恢复



1. 接收方建立这样的机制，如果一个包丢失，则对后续的包继续发送针对该包的重传请求；

2. 一旦发送方接收到三个一样的确认，就知道该包之后出现了错误，立刻重传该包；

3. 此时发送方开始执行“快恢复”算法：

    1. 慢开始门限减半；

    2. cwnd设为慢开始门限减半后的数值；

    3. 执行拥塞避免算法（高起点，线性增长）；

![](http://blog.chinaunix.net/attachment/201402/17/26275986_1392629231ue0O.png?_=3554182)

